{"ast":null,"code":"\"use strict\";\n\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Upload_instances, _Upload_resetLocalBuffersCache, _Upload_addLocalBufferCache;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createURI = exports.upload = exports.Upload = exports.PROTOCOL_REGEX = void 0;\nconst abort_controller_1 = require(\"abort-controller\");\nconst crypto_1 = require(\"crypto\");\nconst extend = require(\"extend\");\nconst gaxios = require(\"gaxios\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst stream_1 = require(\"stream\");\nconst retry = require(\"async-retry\");\nconst uuid = require(\"uuid\");\nconst util_1 = require(\"./util\");\nconst NOT_FOUND_STATUS_CODE = 404;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst DEFAULT_API_ENDPOINT_REGEX = /.*\\.googleapis\\.com/;\nconst packageJson = require('../../package.json');\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\nclass Upload extends stream_1.Writable {\n  constructor(cfg) {\n    super(cfg);\n    _Upload_instances.add(this);\n    this.numBytesWritten = 0;\n    this.numRetries = 0;\n    this.currentInvocationId = {\n      chunk: uuid.v4(),\n      uri: uuid.v4(),\n      offset: uuid.v4()\n    };\n    /**\n     * A cache of buffers written to this instance, ready for consuming\n     */\n    this.writeBuffers = [];\n    this.numChunksReadInRequest = 0;\n    /**\n     * An array of buffers used for caching the most recent upload chunk.\n     * We should not assume that the server received all bytes sent in the request.\n     *  - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n     */\n    this.localWriteCache = [];\n    this.localWriteCacheByteLength = 0;\n    this.upstreamEnded = false;\n    cfg = cfg || {};\n    if (!cfg.bucket || !cfg.file) {\n      throw new Error('A bucket and file name are required');\n    }\n    cfg.authConfig = cfg.authConfig || {};\n    cfg.authConfig.scopes = ['https://www.googleapis.com/auth/devstorage.full_control'];\n    this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n    this.apiEndpoint = 'https://storage.googleapis.com';\n    if (cfg.apiEndpoint) {\n      this.apiEndpoint = this.sanitizeEndpoint(cfg.apiEndpoint);\n      if (!DEFAULT_API_ENDPOINT_REGEX.test(cfg.apiEndpoint)) {\n        this.authClient = gaxios;\n      }\n    }\n    this.baseURI = `${this.apiEndpoint}/upload/storage/v1/b`;\n    this.bucket = cfg.bucket;\n    const cacheKeyElements = [cfg.bucket, cfg.file];\n    if (typeof cfg.generation === 'number') {\n      cacheKeyElements.push(`${cfg.generation}`);\n    }\n    this.cacheKey = cacheKeyElements.join('/');\n    this.customRequestOptions = cfg.customRequestOptions || {};\n    this.file = cfg.file;\n    this.generation = cfg.generation;\n    this.kmsKeyName = cfg.kmsKeyName;\n    this.metadata = cfg.metadata || {};\n    this.offset = cfg.offset;\n    this.origin = cfg.origin;\n    this.params = cfg.params || {};\n    this.userProject = cfg.userProject;\n    this.chunkSize = cfg.chunkSize;\n    this.retryOptions = cfg.retryOptions;\n    if (cfg.key) {\n      const base64Key = Buffer.from(cfg.key).toString('base64');\n      this.encryption = {\n        key: base64Key,\n        hash: (0, crypto_1.createHash)('sha256').update(cfg.key).digest('base64')\n      };\n    }\n    this.predefinedAcl = cfg.predefinedAcl;\n    if (cfg.private) this.predefinedAcl = 'private';\n    if (cfg.public) this.predefinedAcl = 'publicRead';\n    const autoRetry = cfg.retryOptions.autoRetry;\n    this.uriProvidedManually = !!cfg.uri;\n    this.uri = cfg.uri;\n    this.numBytesWritten = 0;\n    this.numRetries = 0; // counter for number of retries currently executed\n    if (!autoRetry) {\n      cfg.retryOptions.maxRetries = 0;\n    }\n    this.timeOfFirstRequest = Date.now();\n    const contentLength = cfg.metadata ? Number(cfg.metadata.contentLength) : NaN;\n    this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n    this.once('writing', () => {\n      if (this.uri) {\n        this.continueUploading();\n      } else {\n        this.createURI(err => {\n          if (err) {\n            return this.destroy(err);\n          }\n          this.startUploading();\n          return;\n        });\n      }\n    });\n  }\n  /**\n   * Prevent 'finish' event until the upload has succeeded.\n   *\n   * @param fireFinishEvent The finish callback\n   */\n  _final(fireFinishEvent = () => {}) {\n    this.upstreamEnded = true;\n    this.once('uploadFinished', fireFinishEvent);\n    process.nextTick(() => {\n      this.emit('upstreamFinished');\n      // it's possible `_write` may not be called - namely for empty object uploads\n      this.emit('writing');\n    });\n  }\n  /**\n   * Handles incoming data from upstream\n   *\n   * @param chunk The chunk to append to the buffer\n   * @param encoding The encoding of the chunk\n   * @param readCallback A callback for when the buffer has been read downstream\n   */\n  _write(chunk, encoding, readCallback = () => {}) {\n    // Backwards-compatible event\n    this.emit('writing');\n    this.writeBuffers.push(typeof chunk === 'string' ? Buffer.from(chunk, encoding) : chunk);\n    this.once('readFromChunkBuffer', readCallback);\n    process.nextTick(() => this.emit('wroteToChunkBuffer'));\n  }\n  /**\n   * Prepends the local buffer to write buffer and resets it.\n   *\n   * @param keepLastBytes number of bytes to keep from the end of the local buffer.\n   */\n  prependLocalBufferToUpstream(keepLastBytes) {\n    // Typically, the upstream write buffers should be smaller than the local\n    // cache, so we can save time by setting the local cache as the new\n    // upstream write buffer array and appending the old array to it\n    let initialBuffers = [];\n    if (keepLastBytes) {\n      // we only want the last X bytes\n      let bytesKept = 0;\n      while (keepLastBytes > bytesKept) {\n        // load backwards because we want the last X bytes\n        // note: `localWriteCacheByteLength` is reset below\n        let buf = this.localWriteCache.pop();\n        if (!buf) break;\n        bytesKept += buf.byteLength;\n        if (bytesKept > keepLastBytes) {\n          // we have gone over the amount desired, let's keep the last X bytes\n          // of this buffer\n          const diff = bytesKept - keepLastBytes;\n          buf = buf.subarray(diff);\n          bytesKept -= diff;\n        }\n        initialBuffers.unshift(buf);\n      }\n    } else {\n      // we're keeping all of the local cache, simply use it as the initial buffer\n      initialBuffers = this.localWriteCache;\n    }\n    // Append the old upstream to the new\n    const append = this.writeBuffers;\n    this.writeBuffers = initialBuffers;\n    for (const buf of append) {\n      this.writeBuffers.push(buf);\n    }\n    // reset last buffers sent\n    __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n  }\n  /**\n   * Retrieves data from upstream's buffer.\n   *\n   * @param limit The maximum amount to return from the buffer.\n   * @returns The data requested.\n   */\n  *pullFromChunkBuffer(limit) {\n    while (limit) {\n      const buf = this.writeBuffers.shift();\n      if (!buf) break;\n      let bufToYield = buf;\n      if (buf.byteLength > limit) {\n        bufToYield = buf.subarray(0, limit);\n        this.writeBuffers.unshift(buf.subarray(limit));\n        limit = 0;\n      } else {\n        limit -= buf.byteLength;\n      }\n      yield bufToYield;\n      // Notify upstream we've read from the buffer and we're able to consume\n      // more. It can also potentially send more data down as we're currently\n      // iterating.\n      this.emit('readFromChunkBuffer');\n    }\n  }\n  /**\n   * A handler for determining if data is ready to be read from upstream.\n   *\n   * @returns If there will be more chunks to read in the future\n   */\n  async waitForNextChunk() {\n    const willBeMoreChunks = await new Promise(resolve => {\n      // There's data available - it should be digested\n      if (this.writeBuffers.length) {\n        return resolve(true);\n      }\n      // The upstream writable ended, we shouldn't expect any more data.\n      if (this.upstreamEnded) {\n        return resolve(false);\n      }\n      // Nothing immediate seems to be determined. We need to prepare some\n      // listeners to determine next steps...\n      const wroteToChunkBufferCallback = () => {\n        removeListeners();\n        return resolve(true);\n      };\n      const upstreamFinishedCallback = () => {\n        removeListeners();\n        // this should be the last chunk, if there's anything there\n        if (this.writeBuffers.length) return resolve(true);\n        return resolve(false);\n      };\n      // Remove listeners when we're ready to callback.\n      const removeListeners = () => {\n        this.removeListener('wroteToChunkBuffer', wroteToChunkBufferCallback);\n        this.removeListener('upstreamFinished', upstreamFinishedCallback);\n      };\n      // If there's data recently written it should be digested\n      this.once('wroteToChunkBuffer', wroteToChunkBufferCallback);\n      // If the upstream finishes let's see if there's anything to grab\n      this.once('upstreamFinished', upstreamFinishedCallback);\n    });\n    return willBeMoreChunks;\n  }\n  /**\n   * Reads data from upstream up to the provided `limit`.\n   * Ends when the limit has reached or no data is expected to be pushed from upstream.\n   *\n   * @param limit The most amount of data this iterator should return. `Infinity` by default.\n   */\n  async *upstreamIterator(limit = Infinity) {\n    // read from upstream chunk buffer\n    while (limit && (await this.waitForNextChunk())) {\n      // read until end or limit has been reached\n      for (const chunk of this.pullFromChunkBuffer(limit)) {\n        limit -= chunk.byteLength;\n        yield chunk;\n      }\n    }\n  }\n  createURI(callback) {\n    if (!callback) {\n      return this.createURIAsync();\n    }\n    this.createURIAsync().then(r => callback(null, r), callback);\n  }\n  async createURIAsync() {\n    const metadata = {\n      ...this.metadata\n    };\n    const headers = {};\n    // Delete content length and content type from metadata if they exist.\n    // These are headers and should not be sent as part of the metadata.\n    if (metadata.contentLength) {\n      headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n      delete metadata.contentLength;\n    }\n    if (metadata.contentType) {\n      headers['X-Upload-Content-Type'] = metadata.contentType;\n      delete metadata.contentType;\n    }\n    // Check if headers already exist before creating new ones\n    const reqOpts = {\n      method: 'POST',\n      url: [this.baseURI, this.bucket, 'o'].join('/'),\n      params: Object.assign({\n        name: this.file,\n        uploadType: 'resumable'\n      }, this.params),\n      data: metadata,\n      headers: {\n        'x-goog-api-client': `${(0, util_1.getRuntimeTrackingString)()} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.uri}`,\n        ...headers\n      }\n    };\n    if (metadata.contentLength) {\n      reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n    }\n    if (metadata.contentType) {\n      reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n    }\n    if (typeof this.generation !== 'undefined') {\n      reqOpts.params.ifGenerationMatch = this.generation;\n    }\n    if (this.kmsKeyName) {\n      reqOpts.params.kmsKeyName = this.kmsKeyName;\n    }\n    if (this.predefinedAcl) {\n      reqOpts.params.predefinedAcl = this.predefinedAcl;\n    }\n    if (this.origin) {\n      reqOpts.headers.Origin = this.origin;\n    }\n    const uri = await retry(async bail => {\n      var _a, _b, _c;\n      try {\n        const res = await this.makeRequest(reqOpts);\n        // We have successfully got a URI we can now create a new invocation id\n        this.currentInvocationId.uri = uuid.v4();\n        return res.headers.location;\n      } catch (err) {\n        const e = err;\n        const apiError = {\n          code: (_a = e.response) === null || _a === void 0 ? void 0 : _a.status,\n          name: (_b = e.response) === null || _b === void 0 ? void 0 : _b.statusText,\n          message: (_c = e.response) === null || _c === void 0 ? void 0 : _c.statusText,\n          errors: [{\n            reason: e.code\n          }]\n        };\n        if (this.retryOptions.maxRetries > 0 && this.retryOptions.retryableErrorFn(apiError)) {\n          throw e;\n        } else {\n          return bail(e);\n        }\n      }\n    }, {\n      retries: this.retryOptions.maxRetries,\n      factor: this.retryOptions.retryDelayMultiplier,\n      maxTimeout: this.retryOptions.maxRetryDelay * 1000,\n      maxRetryTime: this.retryOptions.totalTimeout * 1000 //convert to milliseconds\n    });\n\n    this.uri = uri;\n    this.offset = 0;\n    return uri;\n  }\n  async continueUploading() {\n    if (typeof this.offset === 'number') {\n      this.startUploading();\n      return;\n    }\n    await this.getAndSetOffset();\n    this.startUploading();\n  }\n  async startUploading() {\n    const multiChunkMode = !!this.chunkSize;\n    let responseReceived = false;\n    this.numChunksReadInRequest = 0;\n    if (!this.offset) {\n      this.offset = 0;\n    }\n    // Check if the offset (server) is too far behind the current stream\n    if (this.offset < this.numBytesWritten) {\n      const delta = this.numBytesWritten - this.offset;\n      const message = `The offset is lower than the number of bytes written. The server has ${this.offset} bytes and while ${this.numBytesWritten} bytes has been uploaded - thus ${delta} bytes are missing. Stopping as this could result in data loss. Initiate a new upload to continue.`;\n      this.emit('error', new RangeError(message));\n      return;\n    }\n    // Check if we should 'fast-forward' to the relevant data to upload\n    if (this.numBytesWritten < this.offset) {\n      // 'fast-forward' to the byte where we need to upload.\n      // only push data from the byte after the one we left off on\n      const fastForwardBytes = this.offset - this.numBytesWritten;\n      for await (const _chunk of this.upstreamIterator(fastForwardBytes)) {\n        _chunk; // discard the data up until the point we want\n      }\n\n      this.numBytesWritten = this.offset;\n    }\n    let expectedUploadSize = undefined;\n    // Set `expectedUploadSize` to `contentLength - this.numBytesWritten`, if available\n    if (typeof this.contentLength === 'number') {\n      expectedUploadSize = this.contentLength - this.numBytesWritten;\n    }\n    // `expectedUploadSize` should be no more than the `chunkSize`.\n    // It's possible this is the last chunk request for a multiple\n    // chunk upload, thus smaller than the chunk size.\n    if (this.chunkSize) {\n      expectedUploadSize = expectedUploadSize ? Math.min(this.chunkSize, expectedUploadSize) : this.chunkSize;\n    }\n    // A queue for the upstream data\n    const upstreamQueue = this.upstreamIterator(expectedUploadSize);\n    // The primary read stream for this request. This stream retrieves no more\n    // than the exact requested amount from upstream.\n    const requestStream = new stream_1.Readable({\n      read: async () => {\n        // Don't attempt to retrieve data upstream if we already have a response\n        if (responseReceived) requestStream.push(null);\n        const result = await upstreamQueue.next();\n        if (result.value) {\n          this.numChunksReadInRequest++;\n          if (multiChunkMode) {\n            // save ever buffer used in the request in multi-chunk mode\n            __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, result.value);\n          } else {\n            __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n            __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, result.value);\n          }\n          this.numBytesWritten += result.value.byteLength;\n          this.emit('progress', {\n            bytesWritten: this.numBytesWritten,\n            contentLength: this.contentLength\n          });\n          requestStream.push(result.value);\n        }\n        if (result.done) {\n          requestStream.push(null);\n        }\n      }\n    });\n    const headers = {\n      'x-goog-api-client': `${(0, util_1.getRuntimeTrackingString)()} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.chunk}`\n    };\n    // If using multiple chunk upload, set appropriate header\n    if (multiChunkMode) {\n      // We need to know how much data is available upstream to set the `Content-Range` header.\n      // https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n      for await (const chunk of this.upstreamIterator(expectedUploadSize)) {\n        // This will conveniently track and keep the size of the buffers\n        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, chunk);\n      }\n      // We hit either the expected upload size or the remainder\n      const bytesToUpload = this.localWriteCacheByteLength;\n      // Important: we want to know if the upstream has ended and the queue is empty before\n      // unshifting data back into the queue. This way we will know if this is the last request or not.\n      const isLastChunkOfUpload = !(await this.waitForNextChunk());\n      // Important: put the data back in the queue for the actual upload\n      this.prependLocalBufferToUpstream();\n      let totalObjectSize = this.contentLength;\n      if (typeof this.contentLength !== 'number' && isLastChunkOfUpload) {\n        // Let's let the server know this is the last chunk since\n        // we didn't know the content-length beforehand.\n        totalObjectSize = bytesToUpload + this.numBytesWritten;\n      }\n      // `- 1` as the ending byte is inclusive in the request.\n      const endingByte = bytesToUpload + this.numBytesWritten - 1;\n      // `Content-Length` for multiple chunk uploads is the size of the chunk,\n      // not the overall object\n      headers['Content-Length'] = bytesToUpload;\n      headers['Content-Range'] = `bytes ${this.offset}-${endingByte}/${totalObjectSize}`;\n    } else {\n      headers['Content-Range'] = `bytes ${this.offset}-*/${this.contentLength}`;\n    }\n    const reqOpts = {\n      method: 'PUT',\n      url: this.uri,\n      headers,\n      body: requestStream\n    };\n    try {\n      const resp = await this.makeRequestStream(reqOpts);\n      if (resp) {\n        responseReceived = true;\n        this.responseHandler(resp);\n      }\n    } catch (e) {\n      const err = e;\n      if (this.retryOptions.retryableErrorFn(err)) {\n        this.attemptDelayedRetry({\n          status: NaN,\n          data: err\n        });\n        return;\n      }\n      this.destroy(err);\n    }\n  }\n  // Process the API response to look for errors that came in\n  // the response body.\n  responseHandler(resp) {\n    if (resp.data.error) {\n      this.destroy(resp.data.error);\n      return;\n    }\n    // At this point we can safely create a new id for the chunk\n    this.currentInvocationId.chunk = uuid.v4();\n    const shouldContinueWithNextMultiChunkRequest = this.chunkSize && resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE && resp.headers.range;\n    if (shouldContinueWithNextMultiChunkRequest) {\n      // Use the upper value in this header to determine where to start the next chunk.\n      // We should not assume that the server received all bytes sent in the request.\n      // https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n      const range = resp.headers.range;\n      this.offset = Number(range.split('-')[1]) + 1;\n      // We should not assume that the server received all bytes sent in the request.\n      // - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n      const missingBytes = this.numBytesWritten - this.offset;\n      if (missingBytes) {\n        // As multi-chunk uploads send one chunk per request and pulls one\n        // chunk into the pipeline, prepending the missing bytes back should\n        // be fine for the next request.\n        this.prependLocalBufferToUpstream(missingBytes);\n        this.numBytesWritten -= missingBytes;\n      } else {\n        // No bytes missing - no need to keep the local cache\n        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n      }\n      // continue uploading next chunk\n      this.continueUploading();\n    } else if (!this.isSuccessfulResponse(resp.status)) {\n      const err = new Error('Upload failed');\n      err.code = resp.status;\n      err.name = 'Upload failed';\n      if (resp === null || resp === void 0 ? void 0 : resp.data) {\n        err.errors = [resp === null || resp === void 0 ? void 0 : resp.data];\n      }\n      this.destroy(err);\n    } else {\n      // no need to keep the cache\n      __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n      if (resp && resp.data) {\n        resp.data.size = Number(resp.data.size);\n      }\n      this.emit('metadata', resp.data);\n      // Allow the object (Upload) to continue naturally so the user's\n      // \"finish\" event fires.\n      this.emit('uploadFinished');\n    }\n  }\n  async getAndSetOffset() {\n    const opts = {\n      method: 'PUT',\n      url: this.uri,\n      headers: {\n        'Content-Length': 0,\n        'Content-Range': 'bytes */*',\n        'x-goog-api-client': `${(0, util_1.getRuntimeTrackingString)()} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.offset}`\n      }\n    };\n    try {\n      const resp = await this.makeRequest(opts);\n      // Successfully got the offset we can now create a new offset invocation id\n      this.currentInvocationId.offset = uuid.v4();\n      if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n        if (resp.headers.range) {\n          const range = resp.headers.range;\n          this.offset = Number(range.split('-')[1]) + 1;\n          return;\n        }\n      }\n      this.offset = 0;\n    } catch (e) {\n      const err = e;\n      if (this.retryOptions.retryableErrorFn(err)) {\n        this.attemptDelayedRetry({\n          status: NaN,\n          data: err\n        });\n        return;\n      }\n      this.destroy(err);\n    }\n  }\n  async makeRequest(reqOpts) {\n    if (this.encryption) {\n      reqOpts.headers = reqOpts.headers || {};\n      reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n      reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n      reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n    }\n    if (this.userProject) {\n      reqOpts.params = reqOpts.params || {};\n      reqOpts.params.userProject = this.userProject;\n    }\n    // Let gaxios know we will handle a 308 error code ourselves.\n    reqOpts.validateStatus = status => {\n      return this.isSuccessfulResponse(status) || status === RESUMABLE_INCOMPLETE_STATUS_CODE;\n    };\n    const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n    const res = await this.authClient.request(combinedReqOpts);\n    if (res.data && res.data.error) {\n      throw res.data.error;\n    }\n    return res;\n  }\n  async makeRequestStream(reqOpts) {\n    const controller = new abort_controller_1.default();\n    const errorCallback = () => controller.abort();\n    this.once('error', errorCallback);\n    if (this.userProject) {\n      reqOpts.params = reqOpts.params || {};\n      reqOpts.params.userProject = this.userProject;\n    }\n    reqOpts.signal = controller.signal;\n    reqOpts.validateStatus = () => true;\n    const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n    const res = await this.authClient.request(combinedReqOpts);\n    const successfulRequest = this.onResponse(res);\n    this.removeListener('error', errorCallback);\n    return successfulRequest ? res : null;\n  }\n  /**\n   * @return {bool} is the request good?\n   */\n  onResponse(resp) {\n    if (resp.status !== 200 && this.retryOptions.retryableErrorFn({\n      code: resp.status,\n      message: resp.statusText,\n      name: resp.statusText\n    })) {\n      this.attemptDelayedRetry(resp);\n      return false;\n    }\n    this.emit('response', resp);\n    return true;\n  }\n  /**\n   * @param resp GaxiosResponse object from previous attempt\n   */\n  attemptDelayedRetry(resp) {\n    if (this.numRetries < this.retryOptions.maxRetries) {\n      if (resp.status === NOT_FOUND_STATUS_CODE && this.numChunksReadInRequest === 0) {\n        this.startUploading();\n      } else {\n        const retryDelay = this.getRetryDelay();\n        if (retryDelay <= 0) {\n          this.destroy(new Error(`Retry total time limit exceeded - ${resp.data}`));\n          return;\n        }\n        // Unshift the local cache back in case it's needed for the next request.\n        this.numBytesWritten -= this.localWriteCacheByteLength;\n        this.prependLocalBufferToUpstream();\n        // We don't know how much data has been received by the server.\n        // `continueUploading` will recheck the offset via `getAndSetOffset`.\n        // If `offset` < `numberBytesReceived` then we will raise a RangeError\n        // as we've streamed too much data that has been missed - this should\n        // not be the case for multi-chunk uploads as `lastChunkSent` is the\n        // body of the entire request.\n        this.offset = undefined;\n        setTimeout(this.continueUploading.bind(this), retryDelay);\n      }\n      this.numRetries++;\n    } else {\n      this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n    }\n  }\n  /**\n   * @returns {number} the amount of time to wait before retrying the request\n   */\n  getRetryDelay() {\n    const randomMs = Math.round(Math.random() * 1000);\n    const waitTime = Math.pow(this.retryOptions.retryDelayMultiplier, this.numRetries) * 1000 + randomMs;\n    const maxAllowableDelayMs = this.retryOptions.totalTimeout * 1000 - (Date.now() - this.timeOfFirstRequest);\n    const maxRetryDelayMs = this.retryOptions.maxRetryDelay * 1000;\n    return Math.min(waitTime, maxRetryDelayMs, maxAllowableDelayMs);\n  }\n  /*\n   * Prepare user-defined API endpoint for compatibility with our API.\n   */\n  sanitizeEndpoint(url) {\n    if (!exports.PROTOCOL_REGEX.test(url)) {\n      url = `https://${url}`;\n    }\n    return url.replace(/\\/+$/, ''); // Remove trailing slashes\n  }\n  /**\n   * Check if a given status code is 2xx\n   *\n   * @param status The status code to check\n   * @returns if the status is 2xx\n   */\n  isSuccessfulResponse(status) {\n    return status >= 200 && status < 300;\n  }\n}\nexports.Upload = Upload;\n_Upload_instances = new WeakSet(), _Upload_resetLocalBuffersCache = function _Upload_resetLocalBuffersCache() {\n  this.localWriteCache = [];\n  this.localWriteCacheByteLength = 0;\n}, _Upload_addLocalBufferCache = function _Upload_addLocalBufferCache(buf) {\n  this.localWriteCache.push(buf);\n  this.localWriteCacheByteLength += buf.byteLength;\n};\nfunction upload(cfg) {\n  return new Upload(cfg);\n}\nexports.upload = upload;\nfunction createURI(cfg, callback) {\n  const up = new Upload(cfg);\n  if (!callback) {\n    return up.createURI();\n  }\n  up.createURI().then(r => callback(null, r), callback);\n}\nexports.createURI = createURI;","map":{"version":3,"names":["__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","value","get","_Upload_instances","_Upload_resetLocalBuffersCache","_Upload_addLocalBufferCache","Object","defineProperty","exports","createURI","upload","Upload","PROTOCOL_REGEX","abort_controller_1","require","crypto_1","extend","gaxios","google_auth_library_1","stream_1","retry","uuid","util_1","NOT_FOUND_STATUS_CODE","RESUMABLE_INCOMPLETE_STATUS_CODE","DEFAULT_API_ENDPOINT_REGEX","packageJson","Writable","constructor","cfg","add","numBytesWritten","numRetries","currentInvocationId","chunk","v4","uri","offset","writeBuffers","numChunksReadInRequest","localWriteCache","localWriteCacheByteLength","upstreamEnded","bucket","file","Error","authConfig","scopes","authClient","GoogleAuth","apiEndpoint","sanitizeEndpoint","test","baseURI","cacheKeyElements","generation","push","cacheKey","join","customRequestOptions","kmsKeyName","metadata","origin","params","userProject","chunkSize","retryOptions","key","base64Key","Buffer","from","toString","encryption","hash","createHash","update","digest","predefinedAcl","private","public","autoRetry","uriProvidedManually","maxRetries","timeOfFirstRequest","Date","now","contentLength","Number","NaN","isNaN","once","continueUploading","err","destroy","startUploading","_final","fireFinishEvent","process","nextTick","emit","_write","encoding","readCallback","prependLocalBufferToUpstream","keepLastBytes","initialBuffers","bytesKept","buf","pop","byteLength","diff","subarray","unshift","append","pullFromChunkBuffer","limit","shift","bufToYield","waitForNextChunk","willBeMoreChunks","Promise","resolve","length","wroteToChunkBufferCallback","removeListeners","upstreamFinishedCallback","removeListener","upstreamIterator","Infinity","callback","createURIAsync","then","r","headers","contentType","reqOpts","method","url","assign","name","uploadType","data","getRuntimeTrackingString","version","ifGenerationMatch","Origin","bail","_a","_b","_c","res","makeRequest","location","e","apiError","code","response","status","statusText","message","errors","reason","retryableErrorFn","retries","factor","retryDelayMultiplier","maxTimeout","maxRetryDelay","maxRetryTime","totalTimeout","getAndSetOffset","multiChunkMode","responseReceived","delta","RangeError","fastForwardBytes","_chunk","expectedUploadSize","undefined","Math","min","upstreamQueue","requestStream","Readable","read","result","next","bytesWritten","done","bytesToUpload","isLastChunkOfUpload","totalObjectSize","endingByte","body","resp","makeRequestStream","responseHandler","attemptDelayedRetry","error","shouldContinueWithNextMultiChunkRequest","range","split","missingBytes","isSuccessfulResponse","size","opts","validateStatus","combinedReqOpts","request","controller","default","errorCallback","abort","signal","successfulRequest","onResponse","retryDelay","getRetryDelay","setTimeout","bind","randomMs","round","random","waitTime","pow","maxAllowableDelayMs","maxRetryDelayMs","replace","WeakSet","up"],"sources":["/Users/charlpro/scoreboard/frontend/node_modules/@google-cloud/storage/build/src/resumable-upload.js"],"sourcesContent":["\"use strict\";\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Upload_instances, _Upload_resetLocalBuffersCache, _Upload_addLocalBufferCache;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createURI = exports.upload = exports.Upload = exports.PROTOCOL_REGEX = void 0;\nconst abort_controller_1 = require(\"abort-controller\");\nconst crypto_1 = require(\"crypto\");\nconst extend = require(\"extend\");\nconst gaxios = require(\"gaxios\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst stream_1 = require(\"stream\");\nconst retry = require(\"async-retry\");\nconst uuid = require(\"uuid\");\nconst util_1 = require(\"./util\");\nconst NOT_FOUND_STATUS_CODE = 404;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst DEFAULT_API_ENDPOINT_REGEX = /.*\\.googleapis\\.com/;\nconst packageJson = require('../../package.json');\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\nclass Upload extends stream_1.Writable {\n    constructor(cfg) {\n        super(cfg);\n        _Upload_instances.add(this);\n        this.numBytesWritten = 0;\n        this.numRetries = 0;\n        this.currentInvocationId = {\n            chunk: uuid.v4(),\n            uri: uuid.v4(),\n            offset: uuid.v4(),\n        };\n        /**\n         * A cache of buffers written to this instance, ready for consuming\n         */\n        this.writeBuffers = [];\n        this.numChunksReadInRequest = 0;\n        /**\n         * An array of buffers used for caching the most recent upload chunk.\n         * We should not assume that the server received all bytes sent in the request.\n         *  - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n         */\n        this.localWriteCache = [];\n        this.localWriteCacheByteLength = 0;\n        this.upstreamEnded = false;\n        cfg = cfg || {};\n        if (!cfg.bucket || !cfg.file) {\n            throw new Error('A bucket and file name are required');\n        }\n        cfg.authConfig = cfg.authConfig || {};\n        cfg.authConfig.scopes = [\n            'https://www.googleapis.com/auth/devstorage.full_control',\n        ];\n        this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n        this.apiEndpoint = 'https://storage.googleapis.com';\n        if (cfg.apiEndpoint) {\n            this.apiEndpoint = this.sanitizeEndpoint(cfg.apiEndpoint);\n            if (!DEFAULT_API_ENDPOINT_REGEX.test(cfg.apiEndpoint)) {\n                this.authClient = gaxios;\n            }\n        }\n        this.baseURI = `${this.apiEndpoint}/upload/storage/v1/b`;\n        this.bucket = cfg.bucket;\n        const cacheKeyElements = [cfg.bucket, cfg.file];\n        if (typeof cfg.generation === 'number') {\n            cacheKeyElements.push(`${cfg.generation}`);\n        }\n        this.cacheKey = cacheKeyElements.join('/');\n        this.customRequestOptions = cfg.customRequestOptions || {};\n        this.file = cfg.file;\n        this.generation = cfg.generation;\n        this.kmsKeyName = cfg.kmsKeyName;\n        this.metadata = cfg.metadata || {};\n        this.offset = cfg.offset;\n        this.origin = cfg.origin;\n        this.params = cfg.params || {};\n        this.userProject = cfg.userProject;\n        this.chunkSize = cfg.chunkSize;\n        this.retryOptions = cfg.retryOptions;\n        if (cfg.key) {\n            const base64Key = Buffer.from(cfg.key).toString('base64');\n            this.encryption = {\n                key: base64Key,\n                hash: (0, crypto_1.createHash)('sha256').update(cfg.key).digest('base64'),\n            };\n        }\n        this.predefinedAcl = cfg.predefinedAcl;\n        if (cfg.private)\n            this.predefinedAcl = 'private';\n        if (cfg.public)\n            this.predefinedAcl = 'publicRead';\n        const autoRetry = cfg.retryOptions.autoRetry;\n        this.uriProvidedManually = !!cfg.uri;\n        this.uri = cfg.uri;\n        this.numBytesWritten = 0;\n        this.numRetries = 0; // counter for number of retries currently executed\n        if (!autoRetry) {\n            cfg.retryOptions.maxRetries = 0;\n        }\n        this.timeOfFirstRequest = Date.now();\n        const contentLength = cfg.metadata\n            ? Number(cfg.metadata.contentLength)\n            : NaN;\n        this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n        this.once('writing', () => {\n            if (this.uri) {\n                this.continueUploading();\n            }\n            else {\n                this.createURI(err => {\n                    if (err) {\n                        return this.destroy(err);\n                    }\n                    this.startUploading();\n                    return;\n                });\n            }\n        });\n    }\n    /**\n     * Prevent 'finish' event until the upload has succeeded.\n     *\n     * @param fireFinishEvent The finish callback\n     */\n    _final(fireFinishEvent = () => { }) {\n        this.upstreamEnded = true;\n        this.once('uploadFinished', fireFinishEvent);\n        process.nextTick(() => {\n            this.emit('upstreamFinished');\n            // it's possible `_write` may not be called - namely for empty object uploads\n            this.emit('writing');\n        });\n    }\n    /**\n     * Handles incoming data from upstream\n     *\n     * @param chunk The chunk to append to the buffer\n     * @param encoding The encoding of the chunk\n     * @param readCallback A callback for when the buffer has been read downstream\n     */\n    _write(chunk, encoding, readCallback = () => { }) {\n        // Backwards-compatible event\n        this.emit('writing');\n        this.writeBuffers.push(typeof chunk === 'string' ? Buffer.from(chunk, encoding) : chunk);\n        this.once('readFromChunkBuffer', readCallback);\n        process.nextTick(() => this.emit('wroteToChunkBuffer'));\n    }\n    /**\n     * Prepends the local buffer to write buffer and resets it.\n     *\n     * @param keepLastBytes number of bytes to keep from the end of the local buffer.\n     */\n    prependLocalBufferToUpstream(keepLastBytes) {\n        // Typically, the upstream write buffers should be smaller than the local\n        // cache, so we can save time by setting the local cache as the new\n        // upstream write buffer array and appending the old array to it\n        let initialBuffers = [];\n        if (keepLastBytes) {\n            // we only want the last X bytes\n            let bytesKept = 0;\n            while (keepLastBytes > bytesKept) {\n                // load backwards because we want the last X bytes\n                // note: `localWriteCacheByteLength` is reset below\n                let buf = this.localWriteCache.pop();\n                if (!buf)\n                    break;\n                bytesKept += buf.byteLength;\n                if (bytesKept > keepLastBytes) {\n                    // we have gone over the amount desired, let's keep the last X bytes\n                    // of this buffer\n                    const diff = bytesKept - keepLastBytes;\n                    buf = buf.subarray(diff);\n                    bytesKept -= diff;\n                }\n                initialBuffers.unshift(buf);\n            }\n        }\n        else {\n            // we're keeping all of the local cache, simply use it as the initial buffer\n            initialBuffers = this.localWriteCache;\n        }\n        // Append the old upstream to the new\n        const append = this.writeBuffers;\n        this.writeBuffers = initialBuffers;\n        for (const buf of append) {\n            this.writeBuffers.push(buf);\n        }\n        // reset last buffers sent\n        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n    }\n    /**\n     * Retrieves data from upstream's buffer.\n     *\n     * @param limit The maximum amount to return from the buffer.\n     * @returns The data requested.\n     */\n    *pullFromChunkBuffer(limit) {\n        while (limit) {\n            const buf = this.writeBuffers.shift();\n            if (!buf)\n                break;\n            let bufToYield = buf;\n            if (buf.byteLength > limit) {\n                bufToYield = buf.subarray(0, limit);\n                this.writeBuffers.unshift(buf.subarray(limit));\n                limit = 0;\n            }\n            else {\n                limit -= buf.byteLength;\n            }\n            yield bufToYield;\n            // Notify upstream we've read from the buffer and we're able to consume\n            // more. It can also potentially send more data down as we're currently\n            // iterating.\n            this.emit('readFromChunkBuffer');\n        }\n    }\n    /**\n     * A handler for determining if data is ready to be read from upstream.\n     *\n     * @returns If there will be more chunks to read in the future\n     */\n    async waitForNextChunk() {\n        const willBeMoreChunks = await new Promise(resolve => {\n            // There's data available - it should be digested\n            if (this.writeBuffers.length) {\n                return resolve(true);\n            }\n            // The upstream writable ended, we shouldn't expect any more data.\n            if (this.upstreamEnded) {\n                return resolve(false);\n            }\n            // Nothing immediate seems to be determined. We need to prepare some\n            // listeners to determine next steps...\n            const wroteToChunkBufferCallback = () => {\n                removeListeners();\n                return resolve(true);\n            };\n            const upstreamFinishedCallback = () => {\n                removeListeners();\n                // this should be the last chunk, if there's anything there\n                if (this.writeBuffers.length)\n                    return resolve(true);\n                return resolve(false);\n            };\n            // Remove listeners when we're ready to callback.\n            const removeListeners = () => {\n                this.removeListener('wroteToChunkBuffer', wroteToChunkBufferCallback);\n                this.removeListener('upstreamFinished', upstreamFinishedCallback);\n            };\n            // If there's data recently written it should be digested\n            this.once('wroteToChunkBuffer', wroteToChunkBufferCallback);\n            // If the upstream finishes let's see if there's anything to grab\n            this.once('upstreamFinished', upstreamFinishedCallback);\n        });\n        return willBeMoreChunks;\n    }\n    /**\n     * Reads data from upstream up to the provided `limit`.\n     * Ends when the limit has reached or no data is expected to be pushed from upstream.\n     *\n     * @param limit The most amount of data this iterator should return. `Infinity` by default.\n     */\n    async *upstreamIterator(limit = Infinity) {\n        // read from upstream chunk buffer\n        while (limit && (await this.waitForNextChunk())) {\n            // read until end or limit has been reached\n            for (const chunk of this.pullFromChunkBuffer(limit)) {\n                limit -= chunk.byteLength;\n                yield chunk;\n            }\n        }\n    }\n    createURI(callback) {\n        if (!callback) {\n            return this.createURIAsync();\n        }\n        this.createURIAsync().then(r => callback(null, r), callback);\n    }\n    async createURIAsync() {\n        const metadata = { ...this.metadata };\n        const headers = {};\n        // Delete content length and content type from metadata if they exist.\n        // These are headers and should not be sent as part of the metadata.\n        if (metadata.contentLength) {\n            headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n            delete metadata.contentLength;\n        }\n        if (metadata.contentType) {\n            headers['X-Upload-Content-Type'] = metadata.contentType;\n            delete metadata.contentType;\n        }\n        // Check if headers already exist before creating new ones\n        const reqOpts = {\n            method: 'POST',\n            url: [this.baseURI, this.bucket, 'o'].join('/'),\n            params: Object.assign({\n                name: this.file,\n                uploadType: 'resumable',\n            }, this.params),\n            data: metadata,\n            headers: {\n                'x-goog-api-client': `${(0, util_1.getRuntimeTrackingString)()} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.uri}`,\n                ...headers,\n            },\n        };\n        if (metadata.contentLength) {\n            reqOpts.headers['X-Upload-Content-Length'] =\n                metadata.contentLength.toString();\n        }\n        if (metadata.contentType) {\n            reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n        }\n        if (typeof this.generation !== 'undefined') {\n            reqOpts.params.ifGenerationMatch = this.generation;\n        }\n        if (this.kmsKeyName) {\n            reqOpts.params.kmsKeyName = this.kmsKeyName;\n        }\n        if (this.predefinedAcl) {\n            reqOpts.params.predefinedAcl = this.predefinedAcl;\n        }\n        if (this.origin) {\n            reqOpts.headers.Origin = this.origin;\n        }\n        const uri = await retry(async (bail) => {\n            var _a, _b, _c;\n            try {\n                const res = await this.makeRequest(reqOpts);\n                // We have successfully got a URI we can now create a new invocation id\n                this.currentInvocationId.uri = uuid.v4();\n                return res.headers.location;\n            }\n            catch (err) {\n                const e = err;\n                const apiError = {\n                    code: (_a = e.response) === null || _a === void 0 ? void 0 : _a.status,\n                    name: (_b = e.response) === null || _b === void 0 ? void 0 : _b.statusText,\n                    message: (_c = e.response) === null || _c === void 0 ? void 0 : _c.statusText,\n                    errors: [\n                        {\n                            reason: e.code,\n                        },\n                    ],\n                };\n                if (this.retryOptions.maxRetries > 0 &&\n                    this.retryOptions.retryableErrorFn(apiError)) {\n                    throw e;\n                }\n                else {\n                    return bail(e);\n                }\n            }\n        }, {\n            retries: this.retryOptions.maxRetries,\n            factor: this.retryOptions.retryDelayMultiplier,\n            maxTimeout: this.retryOptions.maxRetryDelay * 1000,\n            maxRetryTime: this.retryOptions.totalTimeout * 1000, //convert to milliseconds\n        });\n        this.uri = uri;\n        this.offset = 0;\n        return uri;\n    }\n    async continueUploading() {\n        if (typeof this.offset === 'number') {\n            this.startUploading();\n            return;\n        }\n        await this.getAndSetOffset();\n        this.startUploading();\n    }\n    async startUploading() {\n        const multiChunkMode = !!this.chunkSize;\n        let responseReceived = false;\n        this.numChunksReadInRequest = 0;\n        if (!this.offset) {\n            this.offset = 0;\n        }\n        // Check if the offset (server) is too far behind the current stream\n        if (this.offset < this.numBytesWritten) {\n            const delta = this.numBytesWritten - this.offset;\n            const message = `The offset is lower than the number of bytes written. The server has ${this.offset} bytes and while ${this.numBytesWritten} bytes has been uploaded - thus ${delta} bytes are missing. Stopping as this could result in data loss. Initiate a new upload to continue.`;\n            this.emit('error', new RangeError(message));\n            return;\n        }\n        // Check if we should 'fast-forward' to the relevant data to upload\n        if (this.numBytesWritten < this.offset) {\n            // 'fast-forward' to the byte where we need to upload.\n            // only push data from the byte after the one we left off on\n            const fastForwardBytes = this.offset - this.numBytesWritten;\n            for await (const _chunk of this.upstreamIterator(fastForwardBytes)) {\n                _chunk; // discard the data up until the point we want\n            }\n            this.numBytesWritten = this.offset;\n        }\n        let expectedUploadSize = undefined;\n        // Set `expectedUploadSize` to `contentLength - this.numBytesWritten`, if available\n        if (typeof this.contentLength === 'number') {\n            expectedUploadSize = this.contentLength - this.numBytesWritten;\n        }\n        // `expectedUploadSize` should be no more than the `chunkSize`.\n        // It's possible this is the last chunk request for a multiple\n        // chunk upload, thus smaller than the chunk size.\n        if (this.chunkSize) {\n            expectedUploadSize = expectedUploadSize\n                ? Math.min(this.chunkSize, expectedUploadSize)\n                : this.chunkSize;\n        }\n        // A queue for the upstream data\n        const upstreamQueue = this.upstreamIterator(expectedUploadSize);\n        // The primary read stream for this request. This stream retrieves no more\n        // than the exact requested amount from upstream.\n        const requestStream = new stream_1.Readable({\n            read: async () => {\n                // Don't attempt to retrieve data upstream if we already have a response\n                if (responseReceived)\n                    requestStream.push(null);\n                const result = await upstreamQueue.next();\n                if (result.value) {\n                    this.numChunksReadInRequest++;\n                    if (multiChunkMode) {\n                        // save ever buffer used in the request in multi-chunk mode\n                        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, result.value);\n                    }\n                    else {\n                        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n                        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, result.value);\n                    }\n                    this.numBytesWritten += result.value.byteLength;\n                    this.emit('progress', {\n                        bytesWritten: this.numBytesWritten,\n                        contentLength: this.contentLength,\n                    });\n                    requestStream.push(result.value);\n                }\n                if (result.done) {\n                    requestStream.push(null);\n                }\n            },\n        });\n        const headers = {\n            'x-goog-api-client': `${(0, util_1.getRuntimeTrackingString)()} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.chunk}`,\n        };\n        // If using multiple chunk upload, set appropriate header\n        if (multiChunkMode) {\n            // We need to know how much data is available upstream to set the `Content-Range` header.\n            // https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n            for await (const chunk of this.upstreamIterator(expectedUploadSize)) {\n                // This will conveniently track and keep the size of the buffers\n                __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, chunk);\n            }\n            // We hit either the expected upload size or the remainder\n            const bytesToUpload = this.localWriteCacheByteLength;\n            // Important: we want to know if the upstream has ended and the queue is empty before\n            // unshifting data back into the queue. This way we will know if this is the last request or not.\n            const isLastChunkOfUpload = !(await this.waitForNextChunk());\n            // Important: put the data back in the queue for the actual upload\n            this.prependLocalBufferToUpstream();\n            let totalObjectSize = this.contentLength;\n            if (typeof this.contentLength !== 'number' && isLastChunkOfUpload) {\n                // Let's let the server know this is the last chunk since\n                // we didn't know the content-length beforehand.\n                totalObjectSize = bytesToUpload + this.numBytesWritten;\n            }\n            // `- 1` as the ending byte is inclusive in the request.\n            const endingByte = bytesToUpload + this.numBytesWritten - 1;\n            // `Content-Length` for multiple chunk uploads is the size of the chunk,\n            // not the overall object\n            headers['Content-Length'] = bytesToUpload;\n            headers['Content-Range'] = `bytes ${this.offset}-${endingByte}/${totalObjectSize}`;\n        }\n        else {\n            headers['Content-Range'] = `bytes ${this.offset}-*/${this.contentLength}`;\n        }\n        const reqOpts = {\n            method: 'PUT',\n            url: this.uri,\n            headers,\n            body: requestStream,\n        };\n        try {\n            const resp = await this.makeRequestStream(reqOpts);\n            if (resp) {\n                responseReceived = true;\n                this.responseHandler(resp);\n            }\n        }\n        catch (e) {\n            const err = e;\n            if (this.retryOptions.retryableErrorFn(err)) {\n                this.attemptDelayedRetry({\n                    status: NaN,\n                    data: err,\n                });\n                return;\n            }\n            this.destroy(err);\n        }\n    }\n    // Process the API response to look for errors that came in\n    // the response body.\n    responseHandler(resp) {\n        if (resp.data.error) {\n            this.destroy(resp.data.error);\n            return;\n        }\n        // At this point we can safely create a new id for the chunk\n        this.currentInvocationId.chunk = uuid.v4();\n        const shouldContinueWithNextMultiChunkRequest = this.chunkSize &&\n            resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE &&\n            resp.headers.range;\n        if (shouldContinueWithNextMultiChunkRequest) {\n            // Use the upper value in this header to determine where to start the next chunk.\n            // We should not assume that the server received all bytes sent in the request.\n            // https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n            const range = resp.headers.range;\n            this.offset = Number(range.split('-')[1]) + 1;\n            // We should not assume that the server received all bytes sent in the request.\n            // - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n            const missingBytes = this.numBytesWritten - this.offset;\n            if (missingBytes) {\n                // As multi-chunk uploads send one chunk per request and pulls one\n                // chunk into the pipeline, prepending the missing bytes back should\n                // be fine for the next request.\n                this.prependLocalBufferToUpstream(missingBytes);\n                this.numBytesWritten -= missingBytes;\n            }\n            else {\n                // No bytes missing - no need to keep the local cache\n                __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n            }\n            // continue uploading next chunk\n            this.continueUploading();\n        }\n        else if (!this.isSuccessfulResponse(resp.status)) {\n            const err = new Error('Upload failed');\n            err.code = resp.status;\n            err.name = 'Upload failed';\n            if (resp === null || resp === void 0 ? void 0 : resp.data) {\n                err.errors = [resp === null || resp === void 0 ? void 0 : resp.data];\n            }\n            this.destroy(err);\n        }\n        else {\n            // no need to keep the cache\n            __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n            if (resp && resp.data) {\n                resp.data.size = Number(resp.data.size);\n            }\n            this.emit('metadata', resp.data);\n            // Allow the object (Upload) to continue naturally so the user's\n            // \"finish\" event fires.\n            this.emit('uploadFinished');\n        }\n    }\n    async getAndSetOffset() {\n        const opts = {\n            method: 'PUT',\n            url: this.uri,\n            headers: {\n                'Content-Length': 0,\n                'Content-Range': 'bytes */*',\n                'x-goog-api-client': `${(0, util_1.getRuntimeTrackingString)()} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.offset}`,\n            },\n        };\n        try {\n            const resp = await this.makeRequest(opts);\n            // Successfully got the offset we can now create a new offset invocation id\n            this.currentInvocationId.offset = uuid.v4();\n            if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n                if (resp.headers.range) {\n                    const range = resp.headers.range;\n                    this.offset = Number(range.split('-')[1]) + 1;\n                    return;\n                }\n            }\n            this.offset = 0;\n        }\n        catch (e) {\n            const err = e;\n            if (this.retryOptions.retryableErrorFn(err)) {\n                this.attemptDelayedRetry({\n                    status: NaN,\n                    data: err,\n                });\n                return;\n            }\n            this.destroy(err);\n        }\n    }\n    async makeRequest(reqOpts) {\n        if (this.encryption) {\n            reqOpts.headers = reqOpts.headers || {};\n            reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n            reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n            reqOpts.headers['x-goog-encryption-key-sha256'] =\n                this.encryption.hash.toString();\n        }\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        // Let gaxios know we will handle a 308 error code ourselves.\n        reqOpts.validateStatus = (status) => {\n            return (this.isSuccessfulResponse(status) ||\n                status === RESUMABLE_INCOMPLETE_STATUS_CODE);\n        };\n        const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n        const res = await this.authClient.request(combinedReqOpts);\n        if (res.data && res.data.error) {\n            throw res.data.error;\n        }\n        return res;\n    }\n    async makeRequestStream(reqOpts) {\n        const controller = new abort_controller_1.default();\n        const errorCallback = () => controller.abort();\n        this.once('error', errorCallback);\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        reqOpts.signal = controller.signal;\n        reqOpts.validateStatus = () => true;\n        const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n        const res = await this.authClient.request(combinedReqOpts);\n        const successfulRequest = this.onResponse(res);\n        this.removeListener('error', errorCallback);\n        return successfulRequest ? res : null;\n    }\n    /**\n     * @return {bool} is the request good?\n     */\n    onResponse(resp) {\n        if (resp.status !== 200 &&\n            this.retryOptions.retryableErrorFn({\n                code: resp.status,\n                message: resp.statusText,\n                name: resp.statusText,\n            })) {\n            this.attemptDelayedRetry(resp);\n            return false;\n        }\n        this.emit('response', resp);\n        return true;\n    }\n    /**\n     * @param resp GaxiosResponse object from previous attempt\n     */\n    attemptDelayedRetry(resp) {\n        if (this.numRetries < this.retryOptions.maxRetries) {\n            if (resp.status === NOT_FOUND_STATUS_CODE &&\n                this.numChunksReadInRequest === 0) {\n                this.startUploading();\n            }\n            else {\n                const retryDelay = this.getRetryDelay();\n                if (retryDelay <= 0) {\n                    this.destroy(new Error(`Retry total time limit exceeded - ${resp.data}`));\n                    return;\n                }\n                // Unshift the local cache back in case it's needed for the next request.\n                this.numBytesWritten -= this.localWriteCacheByteLength;\n                this.prependLocalBufferToUpstream();\n                // We don't know how much data has been received by the server.\n                // `continueUploading` will recheck the offset via `getAndSetOffset`.\n                // If `offset` < `numberBytesReceived` then we will raise a RangeError\n                // as we've streamed too much data that has been missed - this should\n                // not be the case for multi-chunk uploads as `lastChunkSent` is the\n                // body of the entire request.\n                this.offset = undefined;\n                setTimeout(this.continueUploading.bind(this), retryDelay);\n            }\n            this.numRetries++;\n        }\n        else {\n            this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n        }\n    }\n    /**\n     * @returns {number} the amount of time to wait before retrying the request\n     */\n    getRetryDelay() {\n        const randomMs = Math.round(Math.random() * 1000);\n        const waitTime = Math.pow(this.retryOptions.retryDelayMultiplier, this.numRetries) *\n            1000 +\n            randomMs;\n        const maxAllowableDelayMs = this.retryOptions.totalTimeout * 1000 -\n            (Date.now() - this.timeOfFirstRequest);\n        const maxRetryDelayMs = this.retryOptions.maxRetryDelay * 1000;\n        return Math.min(waitTime, maxRetryDelayMs, maxAllowableDelayMs);\n    }\n    /*\n     * Prepare user-defined API endpoint for compatibility with our API.\n     */\n    sanitizeEndpoint(url) {\n        if (!exports.PROTOCOL_REGEX.test(url)) {\n            url = `https://${url}`;\n        }\n        return url.replace(/\\/+$/, ''); // Remove trailing slashes\n    }\n    /**\n     * Check if a given status code is 2xx\n     *\n     * @param status The status code to check\n     * @returns if the status is 2xx\n     */\n    isSuccessfulResponse(status) {\n        return status >= 200 && status < 300;\n    }\n}\nexports.Upload = Upload;\n_Upload_instances = new WeakSet(), _Upload_resetLocalBuffersCache = function _Upload_resetLocalBuffersCache() {\n    this.localWriteCache = [];\n    this.localWriteCacheByteLength = 0;\n}, _Upload_addLocalBufferCache = function _Upload_addLocalBufferCache(buf) {\n    this.localWriteCache.push(buf);\n    this.localWriteCacheByteLength += buf.byteLength;\n};\nfunction upload(cfg) {\n    return new Upload(cfg);\n}\nexports.upload = upload;\nfunction createURI(cfg, callback) {\n    const up = new Upload(cfg);\n    if (!callback) {\n        return up.createURI();\n    }\n    up.createURI().then(r => callback(null, r), callback);\n}\nexports.createURI = createURI;\n//# sourceMappingURL=resumable-upload.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}